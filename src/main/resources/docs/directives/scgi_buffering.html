<h2><span class="editsection">[<a href="/index.php?title=HttpScgiModule&amp;action=edit&amp;section=5" title="Edit section: scgi buffering">edit</a>]</span> <span class="mw-headline" id="scgi_buffering"> scgi_buffering </span></h2><p><b>syntax:</b> scgi_buffering <i>on | off</i> </p><p><b>default:</b> scgi_buffering <i>on</i> </p><p><b>context:</b> <i>http, server, location</i> </p><p><b>version:</b> <i>1.1.5</i> </p><p><b>variables:</b> <i>no</i> </p><p>This directive controls response buffering of the response. </p><p>If buffering is activated, then nginx reads the response from the upstream server as fast as possible, saving it in the buffer as configured by directives <a href="#scgi_buffer_size">scgi_buffer_size</a> and <a href="#scgi_buffers">scgi_buffers</a>. If the response does not fit into memory, then parts of it will be written to disk. </p><p>If buffering is switched off, then the response is synchronously transferred to client immediately as it is received. nginx does not attempt to read the entire answer from the upstream server, the maximum size of data which nginx can accept from the server is set by directive <a href="#scgi_buffer_size">scgi_buffer_size</a>. </p><p>For Comet applications based on long-polling it is important to set scgi_buffering to off, otherwise the asynchronous response is buffered and the Comet does not work. </p><p>Buffering can be set on a per-request basis by setting the X-Accel-Buffering header in the response. </p><br><i>Module: HttpScgiModule</i>